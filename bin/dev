#!/usr/bin/env bash

[ ! -z "$DEBUG" ] && set -x

DIR="$(cd "$(dirname "$0")" && pwd)"
DOTDIR="$HOME/.living-in-a-box"

if [[ "$OSTYPE" == darwin* ]]; then
  VAGRANT="vagrant"
  export FORWARD_DOCKER_PORTS=y
  export VAGRANT_DOTFILE_PATH="$DOTDIR/.vagrant"
  export VAGRANT_VAGRANTFILE="$DIR/../docker/Vagrantfile"
  export DOCKER_HOST=tcp://127.0.0.1:4243
fi

port_arguments() {
  local ports=""
  for port in "$@"; do
    ports+="--publish $port "
  done
  echo $ports
}

run_image() {
  local name=$1
  local ports=$(port_arguments "${@:2}")
  local id=$(docker run \
    --detach \
    --volumes-from ${USER}_${name}_data \
    --name ${USER}_$name \
    $ports \
    gewo/$name)
  echo "Started $name in container $id"
}

create_data_container() {
  local name=$1
  docker ps -a | grep "${USER}_${name}_data" > /dev/null
  if [ $? != 0 ]; then
    docker run -v /data -v /logs -name ${USER}_${name}_data busybox true
  fi
}

start_image() {
  local name=$1
  create_data_container $name
  run_image $@
}

link_arguments() {
  local links=""
  for service in redis mongodb mysql; do
    links+="--link ${USER}_$service:$service "
  done
  echo $links
}

# https://gist.github.com/d11wtq/8699521
ssh_agent_forwarding() {
  if [ -n "$SSH_AUTH_SOCK" ]; then
    local sock_dir=$(dirname $SSH_AUTH_SOCK)
    echo "--volume $sock_dir:$sock_dir --env SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
  fi
}

dotfiles() {
  local dotfiles="${DOTFILES:-.zsh .zshrc .bash_history .bashrc .gitconfig .rspec}"
  local mount_args=""
  if [ -n "$SYNC_DOTFILES" ]; then
    for file in $dotfiles; do
      [ -r "$HOME/$file" ] && mount_args+="--volume $HOME/$file:/$file "
    done
    echo $mount_args
  fi
}

start_services() {
  start_image redis 6379
  start_image mongodb 27017 28017
  start_image mysql 3306
}

start_vagrant() {
  if [ ! -z "$VAGRANT" ]; then
    if ! $VAGRANT status | grep running; then
      $VAGRANT up
    fi
  fi
}

start() {
  start_vagrant
  start_services
}

stop() {
  local running=$(docker ps | tail -n +2 | grep ${USER} | awk '{ print $1 }')
  if [ "$running" != "" ]; then
    docker stop $running
    docker rm $running
  fi
}

kill_() {
  local containers=$(docker ps -a | tail -n +2 | grep -v "_data" | \
    grep ${USER} | awk '{ print $1 }')
  if [ "$containers" != "" ]; then
    docker stop $containers
    docker rm $containers
  fi
}

shell() {
  [ -n "$VAGRANT" ] && local mnt="/vagrant"
  [ -n "$PORT" ] && local port="${PORT}:"
  [[ "$SHELL" =~ zsh ]] && local shell="zsh"

  local id=$(docker run \
    --detach \
    --interactive --tty \
    --volume "${mnt:-$PWD}":/mnt \
    --publish ${port}3000 \
    $(dotfiles) \
    $(ssh_agent_forwarding) \
    $(link_arguments) \
    ${1:-gewo/rails} \
    ${shell:-bash})
  echo "port 3000 forwarded to $(docker port $id 3000)"
  docker attach $id
  sleep 1 && docker rm $id >/dev/null
}

build_images() {
  $DIR/build_images
}

update() {
  cd $DIR/.. && git pull
  images=(base redis mysql mongodb node php rails)
  for image in ${images[@]}; do
    docker pull gewo/$image
  done
}

usage() {
  echo "$0 [start,stop,kill,shell,build_images,vagrant,docker]"
  exit 1
}

cmd="$1"
shift

case "$cmd" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  kill)
    kill_
    ;;
  shell)
    shell ${@}
    ;;
  build_images)
    build_images
    ;;
  update)
    update
    ;;
  vagrant)
    [ ! -z "$VAGRANT" ] && vagrant ${@}
    ;;
  docker)
    docker ${@}
    ;;
  *)
    usage
    ;;
esac
